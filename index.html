

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Colorido</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');
        
        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #1a1c2c, #3d375e);
            color: white;
            overflow-x: hidden;
            touch-action: manipulation;
        }
        
        .tetris-container {
            display: grid;
            grid-template-rows: repeat(20, 1fr);
            grid-template-columns: repeat(10, 1fr);
            gap: 1px;
            border: 4px solid #7d5fff;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 20px rgba(125, 95, 255, 0.5);
        }
        
        .cell {
            aspect-ratio: 1/1;
            border-radius: 2px;
            transition: background-color 0.1s;
        }
        
        .next-piece-container {
            display: grid;
            grid-template-rows: repeat(4, 1fr);
            grid-template-columns: repeat(4, 1fr);
            gap: 1px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #7d5fff;
            border-radius: 8px;
        }
        
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 8px;
        }
        
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .color-option:hover {
            transform: scale(1.2);
        }
        
        .btn {
            transition: all 0.3s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .level-badge {
            position: relative;
            overflow: hidden;
        }
        
        .level-badge::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: rotate(45deg);
            animation: shine 2s infinite;
        }
        
        @keyframes shine {
            0% {
                left: -50%;
            }
            100% {
                left: 150%;
            }
        }
        
        .records-table {
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .records-table th, .records-table td {
            padding: 10px;
            text-align: center;
        }
        
        .records-table th {
            background-color: #7d5fff;
            color: white;
        }
        
        .records-table tr:nth-child(even) {
            background-color: rgba(125, 95, 255, 0.1);
        }
        
        .records-table tr:nth-child(odd) {
            background-color: rgba(125, 95, 255, 0.05);
        }
        
        .records-table tr:hover {
            background-color: rgba(125, 95, 255, 0.2);
        }
        
        .tab-active {
            background-color: #7d5fff;
            color: white;
        }
        
        .tab {
            transition: all 0.3s;
        }
        
        .tab:hover {
            background-color: rgba(125, 95, 255, 0.5);
        }
        
        .settings-container {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px solid #7d5fff;
        }
        
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        .line-clear-animation {
            animation: lineClear 0.5s;
        }
        
        @keyframes lineClear {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.5;
                background-color: white !important;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        .level-up-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(125, 95, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            animation: levelUp 2s forwards;
            z-index: 20;
            text-align: center;
            box-shadow: 0 0 20px rgba(125, 95, 255, 0.8);
        }
        
        @keyframes levelUp {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }
        
        .control-button {
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">
    <div class="container mx-auto max-w-6xl">
        <h1 class="text-4xl md:text-5xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-500">Tetris Colorido</h1>
        
        <div class="flex flex-col md:flex-row gap-6">
            <!-- Área principal do jogo -->
            <div class="flex-1 relative">
                <div id="game-container" class="relative w-full max-w-md mx-auto">
                    <div id="tetris-container" class="tetris-container w-full aspect-[1/2]"></div>
                    
                    <div id="game-over" class="game-over-overlay hidden">
                        <h2 class="text-3xl font-bold mb-4 text-red-500">Game Over!</h2>
                        <p class="text-xl mb-6">Pontuação: <span id="final-score">0</span></p>
                        <div class="mb-6">
                            <label for="player-name" class="block mb-2">Seu nome:</label>
                            <input type="text" id="player-name" maxlength="10" class="bg-gray-800 text-white px-4 py-2 rounded-lg border border-purple-500 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        </div>
                        <button id="save-score" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg mb-4 btn">
                            Salvar Pontuação
                        </button>
                        <button id="restart-game" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg btn">
                            Jogar Novamente
                        </button>
                    </div>
                </div>
                
                <!-- Controles para dispositivos móveis -->
                <div class="mt-6 flex flex-col items-center md:hidden">
                    <button id="rotate-btn" class="control-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full mb-4 btn">
                        Girar ↻
                    </button>
                    <div class="flex justify-center gap-4">
                        <button id="left-btn" class="control-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full btn">
                            ←
                        </button>
                        <button id="down-btn" class="control-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full btn">
                            ↓
                        </button>
                        <button id="right-btn" class="control-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full btn">
                            →
                        </button>
                    </div>
                    <button id="drop-btn" class="control-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-full mt-4 btn">
                        Queda ↓↓
                    </button>
                </div>
            </div>
            
            <!-- Painel lateral -->
            <div class="md:w-80 flex flex-col gap-6">
                <!-- Tabs -->
                <div class="flex rounded-lg overflow-hidden">
                    <button id="info-tab" class="tab tab-active flex-1 py-2 px-4 text-center font-semibold">Jogo</button>
                    <button id="records-tab" class="tab flex-1 py-2 px-4 text-center font-semibold">Recordes</button>
                    <button id="settings-tab" class="tab flex-1 py-2 px-4 text-center font-semibold">Personalizar</button>
                </div>
                
                <!-- Painel de informações do jogo -->
                <div id="info-panel" class="bg-gray-900 bg-opacity-50 p-4 rounded-lg">
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-2">Próxima peça:</h3>
                        <div id="next-piece" class="next-piece-container w-24 h-24 mx-auto"></div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-2">Pontuação:</h3>
                        <div id="score" class="text-3xl font-bold text-center">0</div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-2">Nível:</h3>
                        <div id="level" class="level-badge text-2xl font-bold text-center bg-purple-700 rounded-lg py-1">1</div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-2">Linhas:</h3>
                        <div id="lines" class="text-xl font-bold text-center">0</div>
                    </div>
                    
                    <div class="flex gap-4">
                        <button id="start-pause" class="btn bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg flex-1">
                            Iniciar
                        </button>
                        <button id="reset" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg flex-1">
                            Reiniciar
                        </button>
                    </div>
                    
                    <div class="mt-6">
                        <h3 class="text-lg font-semibold mb-2">Controles:</h3>
                        <ul class="text-sm space-y-1">
                            <li>← → : Mover peça</li>
                            <li>↑ : Girar peça</li>
                            <li>↓ : Descer mais rápido</li>
                            <li>Espaço : Queda instantânea</li>
                        </ul>
                    </div>
                </div>
                
                <!-- Painel de recordes -->
                <div id="records-panel" class="bg-gray-900 bg-opacity-50 p-4 rounded-lg hidden">
                    <h3 class="text-xl font-semibold mb-4 text-center">Melhores Pontuações</h3>
                    <table class="records-table">
                        <thead>
                            <tr>
                                <th>Pos.</th>
                                <th>Nome</th>
                                <th>Pontos</th>
                                <th>Nível</th>
                            </tr>
                        </thead>
                        <tbody id="records-body">
                            <!-- Será preenchido com JavaScript -->
                        </tbody>
                    </table>
                    <button id="clear-records" class="btn bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full">
                        Limpar Recordes
                    </button>
                </div>
                
                <!-- Painel de configurações -->
                <div id="settings-panel" class="bg-gray-900 bg-opacity-50 p-4 rounded-lg hidden">
                    <h3 class="text-xl font-semibold mb-4 text-center">Personalização</h3>
                    
                    <div class="settings-container p-4 mb-4">
                        <h4 class="font-semibold mb-2">Dificuldade Inicial:</h4>
                        <div class="flex gap-2">
                            <button class="difficulty-btn btn flex-1 py-1 px-3 rounded-lg bg-green-600 hover:bg-green-700" data-level="1">Fácil</button>
                            <button class="difficulty-btn btn flex-1 py-1 px-3 rounded-lg bg-yellow-600 hover:bg-yellow-700" data-level="5">Médio</button>
                            <button class="difficulty-btn btn flex-1 py-1 px-3 rounded-lg bg-red-600 hover:bg-red-700" data-level="10">Difícil</button>
                        </div>
                    </div>
                    
                    <div class="settings-container p-4 mb-4">
                        <h4 class="font-semibold mb-2">Tema de Cores:</h4>
                        <div class="flex flex-wrap gap-3 justify-center">
                            <div class="color-option bg-gradient-to-br from-purple-500 to-pink-500" data-theme="default"></div>
                            <div class="color-option bg-gradient-to-br from-blue-500 to-teal-500" data-theme="ocean"></div>
                            <div class="color-option bg-gradient-to-br from-red-500 to-yellow-500" data-theme="fire"></div>
                            <div class="color-option bg-gradient-to-br from-green-500 to-lime-500" data-theme="forest"></div>
                            <div class="color-option bg-gradient-to-br from-gray-700 to-gray-900" data-theme="mono"></div>
                            <div class="color-option bg-gradient-to-br from-yellow-400 to-orange-500" data-theme="retro"></div>
                        </div>
                    </div>
                    
                    <div class="settings-container p-4 mb-4">
                        <h4 class="font-semibold mb-2">Efeitos Visuais:</h4>
                        <div class="flex items-center mb-2">
                            <input type="checkbox" id="ghost-piece" class="mr-2 h-5 w-5 accent-purple-600" checked>
                            <label for="ghost-piece">Mostrar peça fantasma</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="animations" class="mr-2 h-5 w-5 accent-purple-600" checked>
                            <label for="animations">Animações</label>
                        </div>
                    </div>
                    
                    <div class="settings-container p-4">
                        <h4 class="font-semibold mb-2">Tamanho do Tabuleiro:</h4>
                        <div class="flex gap-2">
                            <button class="board-size-btn btn flex-1 py-1 px-3 rounded-lg bg-blue-600 hover:bg-blue-700" data-size="standard">Padrão</button>
                            <button class="board-size-btn btn flex-1 py-1 px-3 rounded-lg bg-blue-600 hover:bg-blue-700" data-size="wide">Largo</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="level-up-notification" class="level-up-notification hidden">
            <h3 class="text-2xl font-bold mb-2">Nível Aumentou!</h3>
            <p class="text-xl">Agora você está no nível <span id="new-level">2</span></p>
        </div>
        
        <div class="text-center text-sm text-gray-400 mt-8">
            Use as setas do teclado para jogar. Pressione P para pausar o jogo.
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Configurações do jogo
            const config = {
                rows: 20,
                cols: 10,
                initialLevel: 1,
                theme: 'default',
                showGhostPiece: true,
                enableAnimations: true,
                boardSize: 'standard'
            };
            
            // Cores dos temas
            const themes = {
                default: ['#FF4D6D', '#7B2CBF', '#3A86FF', '#8AC926', '#FFCA3A', '#FF924C', '#FF85EA'],
                ocean: ['#48CAE4', '#00B4D8', '#0096C7', '#0077B6', '#023E8A', '#03045E', '#90E0EF'],
                fire: ['#FF4800', '#FF7900', '#FFB600', '#FF2400', '#FF5C00', '#FF9500', '#FFD000'],
                forest: ['#2D6A4F', '#40916C', '#52B788', '#74C69D', '#95D5B2', '#B7E4C7', '#D8F3DC'],
                mono: ['#D3D3D3', '#BDBDBD', '#A6A6A6', '#8F8F8F', '#787878', '#616161', '#4A4A4A'],
                retro: ['#F94144', '#F3722C', '#F8961E', '#F9C74F', '#90BE6D', '#43AA8B', '#577590']
            };
            
            // Variáveis do jogo
            let board = [];
            let currentPiece = null;
            let nextPiece = null;
            let gameInterval = null;
            let isPaused = false;
            let isGameOver = false;
            let score = 0;
            let level = config.initialLevel;
            let lines = 0;
            let speed = 1000 - (level - 1) * 50; // Velocidade baseada no nível
            
            // Elementos DOM
            const tetrisContainer = document.getElementById('tetris-container');
            const nextPieceContainer = document.getElementById('next-piece');
            const scoreElement = document.getElementById('score');
            const levelElement = document.getElementById('level');
            const linesElement = document.getElementById('lines');
            const startPauseButton = document.getElementById('start-pause');
            const resetButton = document.getElementById('reset');
            const gameOverElement = document.getElementById('game-over');
            const finalScoreElement = document.getElementById('final-score');
            const playerNameInput = document.getElementById('player-name');
            const saveScoreButton = document.getElementById('save-score');
            const restartGameButton = document.getElementById('restart-game');
            const recordsBody = document.getElementById('records-body');
            const clearRecordsButton = document.getElementById('clear-records');
            const levelUpNotification = document.getElementById('level-up-notification');
            const newLevelElement = document.getElementById('new-level');
            
            // Botões de controle para dispositivos móveis
            const rotateBtn = document.getElementById('rotate-btn');
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');
            const downBtn = document.getElementById('down-btn');
            const dropBtn = document.getElementById('drop-btn');
            
            // Tabs
            const infoTab = document.getElementById('info-tab');
            const recordsTab = document.getElementById('records-tab');
            const settingsTab = document.getElementById('settings-tab');
            const infoPanel = document.getElementById('info-panel');
            const recordsPanel = document.getElementById('records-panel');
            const settingsPanel = document.getElementById('settings-panel');
            
            // Configurações
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            const colorOptions = document.querySelectorAll('.color-option');
            const ghostPieceCheckbox = document.getElementById('ghost-piece');
            const animationsCheckbox = document.getElementById('animations');
            const boardSizeButtons = document.querySelectorAll('.board-size-btn');
            
            // Definição das peças de Tetris
            const pieces = [
                { // I
                    shape: [
                        [0, 0, 0, 0],
                        [1, 1, 1, 1],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ],
                    color: 0
                },
                { // J
                    shape: [
                        [2, 0, 0],
                        [2, 2, 2],
                        [0, 0, 0]
                    ],
                    color: 1
                },
                { // L
                    shape: [
                        [0, 0, 3],
                        [3, 3, 3],
                        [0, 0, 0]
                    ],
                    color: 2
                },
                { // O
                    shape: [
                        [4, 4],
                        [4, 4]
                    ],
                    color: 3
                },
                { // S
                    shape: [
                        [0, 5, 5],
                        [5, 5, 0],
                        [0, 0, 0]
                    ],
                    color: 4
                },
                { // T
                    shape: [
                        [0, 6, 0],
                        [6, 6, 6],
                        [0, 0, 0]
                    ],
                    color: 5
                },
                { // Z
                    shape: [
                        [7, 7, 0],
                        [0, 7, 7],
                        [0, 0, 0]
                    ],
                    color: 6
                }
            ];
            
            // Inicialização do jogo
            function initGame() {
                createBoard();
                createNextPieceDisplay();
                updateTheme();
                loadHighScores();
                
                // Eventos de teclado
                document.addEventListener('keydown', handleKeyPress);
                
                // Eventos de botões
                startPauseButton.addEventListener('click', toggleStartPause);
                resetButton.addEventListener('click', resetGame);
                saveScoreButton.addEventListener('click', saveHighScore);
                restartGameButton.addEventListener('click', resetGame);
                clearRecordsButton.addEventListener('click', clearHighScores);
                
                // Eventos de controles móveis
                if (rotateBtn) {
                    rotateBtn.addEventListener('click', () => rotatePiece());
                    leftBtn.addEventListener('click', () => movePiece('left'));
                    rightBtn.addEventListener('click', () => movePiece('right'));
                    downBtn.addEventListener('click', () => movePiece('down'));
                    dropBtn.addEventListener('click', () => dropPiece());
                    
                    // Prevenir comportamento padrão de toque para evitar zoom
                    [rotateBtn, leftBtn, rightBtn, downBtn, dropBtn].forEach(btn => {
                        btn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            btn.click();
                        });
                    });
                }
                
                // Tabs
                infoTab.addEventListener('click', () => switchTab('info'));
                recordsTab.addEventListener('click', () => switchTab('records'));
                settingsTab.addEventListener('click', () => switchTab('settings'));
                
                // Configurações
                difficultyButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        config.initialLevel = parseInt(btn.dataset.level);
                        highlightSelectedButton(difficultyButtons, btn);
                    });
                });
                
                colorOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        config.theme = option.dataset.theme;
                        highlightSelectedOption(colorOptions, option);
                        updateTheme();
                    });
                });
                
                ghostPieceCheckbox.addEventListener('change', () => {
                    config.showGhostPiece = ghostPieceCheckbox.checked;
                    if (currentPiece) {
                        drawBoard();
                    }
                });
                
                animationsCheckbox.addEventListener('change', () => {
                    config.enableAnimations = animationsCheckbox.checked;
                });
                
                boardSizeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        config.boardSize = btn.dataset.size;
                        highlightSelectedButton(boardSizeButtons, btn);
                        updateBoardSize();
                    });
                });
                
                // Selecionar opções padrão
                highlightSelectedButton(difficultyButtons, difficultyButtons[0]);
                highlightSelectedOption(colorOptions, colorOptions[0]);
                highlightSelectedButton(boardSizeButtons, boardSizeButtons[0]);
            }
            
            function highlightSelectedButton(buttons, selected) {
                buttons.forEach(btn => {
                    btn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                    btn.classList.add('bg-opacity-70');
                });
                selected.classList.add('bg-purple-600', 'hover:bg-purple-700');
                selected.classList.remove('bg-opacity-70');
            }
            
            function highlightSelectedOption(options, selected) {
                options.forEach(opt => {
                    opt.style.transform = 'scale(1)';
                    opt.style.boxShadow = 'none';
                });
                selected.style.transform = 'scale(1.2)';
                selected.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.5)';
            }
            
            function updateBoardSize() {
                if (config.boardSize === 'wide') {
                    config.cols = 12;
                } else {
                    config.cols = 10;
                }
                resetGame();
            }
            
            function updateTheme() {
                document.documentElement.style.setProperty('--theme-gradient', 
                    `linear-gradient(135deg, ${themes[config.theme][0]}, ${themes[config.theme][6]})`);
                
                if (currentPiece) {
                    drawBoard();
                }
            }
            
            function switchTab(tab) {
                // Esconder todos os painéis
                infoPanel.classList.add('hidden');
                recordsPanel.classList.add('hidden');
                settingsPanel.classList.add('hidden');
                
                // Remover classe ativa de todas as tabs
                infoTab.classList.remove('tab-active');
                recordsTab.classList.remove('tab-active');
                settingsTab.classList.remove('tab-active');
                
                // Mostrar o painel selecionado e ativar a tab
                if (tab === 'info') {
                    infoPanel.classList.remove('hidden');
                    infoTab.classList.add('tab-active');
                } else if (tab === 'records') {
                    recordsPanel.classList.remove('hidden');
                    recordsTab.classList.add('tab-active');
                    loadHighScores(); // Atualizar recordes ao abrir a tab
                } else if (tab === 'settings') {
                    settingsPanel.classList.remove('hidden');
                    settingsTab.classList.add('tab-active');
                }
            }
            
            function createBoard() {
                tetrisContainer.innerHTML = '';
                board = Array(config.rows).fill().map(() => Array(config.cols).fill(0));
                
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        tetrisContainer.appendChild(cell);
                    }
                }
                
                // Ajustar o grid do tabuleiro
                tetrisContainer.style.gridTemplateRows = `repeat(${config.rows}, 1fr)`;
                tetrisContainer.style.gridTemplateColumns = `repeat(${config.cols}, 1fr)`;
            }
            
            function createNextPieceDisplay() {
                nextPieceContainer.innerHTML = '';
                
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        nextPieceContainer.appendChild(cell);
                    }
                }
            }
            
            function drawBoard() {
                // Limpar o tabuleiro visual
                const cells = tetrisContainer.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.style.backgroundColor = 'transparent';
                    cell.style.border = 'none';
                    cell.classList.remove('line-clear-animation');
                });
                
                // Desenhar peças fixas no tabuleiro
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        if (board[row][col] > 0) {
                            const colorIndex = board[row][col] - 1;
                            const cell = tetrisContainer.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            if (cell) {
                                cell.style.backgroundColor = themes[config.theme][colorIndex];
                            }
                        }
                    }
                }
                
                // Desenhar peça fantasma
                if (config.showGhostPiece && currentPiece) {
                    const ghostPiece = {
                        shape: [...currentPiece.shape],
                        row: currentPiece.row,
                        col: currentPiece.col,
                        color: currentPiece.color
                    };
                    
                    while (isValidMove(ghostPiece.shape, ghostPiece.row + 1, ghostPiece.col)) {
                        ghostPiece.row++;
                    }
                    
                    drawPiece(ghostPiece, true);
                }
                
                // Desenhar peça atual
                if (currentPiece) {
                    drawPiece(currentPiece, false);
                }
            }
            
            function drawPiece(piece, isGhost) {
                const shape = piece.shape;
                const row = piece.row;
                const col = piece.col;
                const colorIndex = piece.color;
                
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c] > 0) {
                            const boardRow = row + r;
                            const boardCol = col + c;
                            
                            if (boardRow >= 0 && boardRow < config.rows && boardCol >= 0 && boardCol < config.cols) {
                                const cell = tetrisContainer.querySelector(`[data-row="${boardRow}"][data-col="${boardCol}"]`);
                                if (cell) {
                                    if (isGhost) {
                                        cell.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                                        cell.style.border = `1px solid ${themes[config.theme][colorIndex]}`;
                                    } else {
                                        cell.style.backgroundColor = themes[config.theme][colorIndex];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            function drawNextPiece() {
                const cells = nextPieceContainer.querySelectorAll('.cell');
                cells.forEach(cell => {
                    cell.style.backgroundColor = 'transparent';
                });
                
                if (!nextPiece) return;
                
                const shape = nextPiece.shape;
                const colorIndex = nextPiece.color;
                
                // Centralizar a peça no display
                const offsetRow = (4 - shape.length) / 2;
                const offsetCol = (4 - shape[0].length) / 2;
                
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c] > 0) {
                            const displayRow = Math.floor(offsetRow) + r;
                            const displayCol = Math.floor(offsetCol) + c;
                            const index = displayRow * 4 + displayCol;
                            
                            if (cells[index]) {
                                cells[index].style.backgroundColor = themes[config.theme][colorIndex];
                            }
                        }
                    }
                }
            }
            
            function getRandomPiece() {
                const randomIndex = Math.floor(Math.random() * pieces.length);
                const piece = JSON.parse(JSON.stringify(pieces[randomIndex]));
                
                return {
                    shape: piece.shape,
                    color: piece.color,
                    row: 0,
                    col: Math.floor((config.cols - piece.shape[0].length) / 2)
                };
            }
            
            function isValidMove(shape, newRow, newCol) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c] > 0) {
                            const boardRow = newRow + r;
                            const boardCol = newCol + c;
                            
                            // Verificar limites do tabuleiro
                            if (boardRow >= config.rows || boardCol < 0 || boardCol >= config.cols) {
                                return false;
                            }
                            
                            // Verificar colisão com outras peças
                            if (boardRow >= 0 && board[boardRow][boardCol] > 0) {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }
            
            function rotatePiece() {
                if (!currentPiece || isPaused || isGameOver) return;
                
                const shape = currentPiece.shape;
                const newShape = Array(shape[0].length).fill().map(() => Array(shape.length).fill(0));
                
                // Rotação no sentido horário
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        newShape[c][shape.length - 1 - r] = shape[r][c];
                    }
                }
                
                // Verificar se a rotação é válida
                if (isValidMove(newShape, currentPiece.row, currentPiece.col)) {
                    currentPiece.shape = newShape;
                    drawBoard();
                } else {
                    // Tentar ajustar a posição (wall kick)
                    const kicks = [
                        {row: 0, col: 1},  // Direita
                        {row: 0, col: -1}, // Esquerda
                        {row: -1, col: 0}, // Cima
                        {row: 1, col: 0}   // Baixo
                    ];
                    
                    for (const kick of kicks) {
                        if (isValidMove(newShape, currentPiece.row + kick.row, currentPiece.col + kick.col)) {
                            currentPiece.shape = newShape;
                            currentPiece.row += kick.row;
                            currentPiece.col += kick.col;
                            drawBoard();
                            return;
                        }
                    }
                }
            }
            
            function movePiece(direction) {
                if (!currentPiece || isPaused || isGameOver) return;
                
                let newRow = currentPiece.row;
                let newCol = currentPiece.col;
                
                switch (direction) {
                    case 'left':
                        newCol--;
                        break;
                    case 'right':
                        newCol++;
                        break;
                    case 'down':
                        newRow++;
                        break;
                }
                
                if (isValidMove(currentPiece.shape, newRow, newCol)) {
                    currentPiece.row = newRow;
                    currentPiece.col = newCol;
                    drawBoard();
                    return true;
                }
                
                // Se não conseguir mover para baixo, fixar a peça
                if (direction === 'down') {
                    lockPiece();
                    return false;
                }
                
                return false;
            }
            
            function dropPiece() {
                if (!currentPiece || isPaused || isGameOver) return;
                
                while (movePiece('down')) {
                    // Continua movendo para baixo até não poder mais
                }
            }
            
            function lockPiece() {
                if (!currentPiece) return;
                
                // Fixar a peça no tabuleiro
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c] > 0) {
                            const boardRow = currentPiece.row + r;
                            const boardCol = currentPiece.col + c;
                            
                            if (boardRow >= 0 && boardRow < config.rows && boardCol >= 0 && boardCol < config.cols) {
                                board[boardRow][boardCol] = currentPiece.shape[r][c];
                            }
                        }
                    }
                }
                
                // Verificar linhas completas
                checkLines();
                
                // Próxima peça
                spawnPiece();
            }
            
            function checkLines() {
                let linesCleared = 0;
                const linesToClear = [];
                
                // Encontrar linhas completas
                for (let row = config.rows - 1; row >= 0; row--) {
                    if (board[row].every(cell => cell > 0)) {
                        linesToClear.push(row);
                        linesCleared++;
                    }
                }
                
                if (linesCleared > 0) {
                    // Animar linhas que serão removidas
                    if (config.enableAnimations) {
                        animateLineClear(linesToClear, () => {
                            removeLines(linesToClear);
                            updateScore(linesCleared);
                        });
                    } else {
                        removeLines(linesToClear);
                        updateScore(linesCleared);
                    }
                }
            }
            
            function animateLineClear(linesToClear, callback) {
                for (const row of linesToClear) {
                    for (let col = 0; col < config.cols; col++) {
                        const cell = tetrisContainer.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.classList.add('line-clear-animation');
                        }
                    }
                }
                
                setTimeout(callback, 500);
            }
            
            function removeLines(linesToClear) {
                // Remover linhas de baixo para cima
                linesToClear.sort((a, b) => b - a);
                
                for (const row of linesToClear) {
                    // Remover a linha
                    board.splice(row, 1);
                    // Adicionar uma nova linha vazia no topo
                    board.unshift(Array(config.cols).fill(0));
                }
                
                drawBoard();
            }
            
            function updateScore(linesCleared) {
                // Pontuação baseada no número de linhas e nível
                const points = [0, 100, 300, 500, 800];
                score += points[linesCleared] * level;
                lines += linesCleared;
                
                // Atualizar nível a cada 10 linhas
                const newLevel = Math.floor(lines / 10) + config.initialLevel;
                if (newLevel > level) {
                    level = newLevel;
                    speed = Math.max(100, 1000 - (level - 1) * 50);
                    
                    // Mostrar notificação de aumento de nível
                    if (config.enableAnimations) {
                        showLevelUpNotification();
                    }
                    
                    // Atualizar intervalo do jogo
                    if (gameInterval) {
                        clearInterval(gameInterval);
                        gameInterval = setInterval(gameLoop, speed);
                    }
                }
                
                // Atualizar interface
                scoreElement.textContent = score;
                levelElement.textContent = level;
                linesElement.textContent = lines;
            }
            
            function showLevelUpNotification() {
                newLevelElement.textContent = level;
                levelUpNotification.classList.remove('hidden');
                
                setTimeout(() => {
                    levelUpNotification.classList.add('hidden');
                }, 2000);
            }
            
            function spawnPiece() {
                if (nextPiece) {
                    currentPiece = nextPiece;
                } else {
                    currentPiece = getRandomPiece();
                }
                
                nextPiece = getRandomPiece();
                drawNextPiece();
                
                // Verificar game over
                if (!isValidMove(currentPiece.shape, currentPiece.row, currentPiece.col)) {
                    gameOver();
                    return;
                }
                
                drawBoard();
            }
            
            function gameLoop() {
                if (isPaused || isGameOver) return;
                
                movePiece('down');
            }
            
            function startGame() {
                if (isGameOver) {
                    resetGame();
                    return;
                }
                
                if (!currentPiece) {
                    spawnPiece();
                }
                
                isPaused = false;
                startPauseButton.textContent = 'Pausar';
                startPauseButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                startPauseButton.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                
                if (gameInterval) {
                    clearInterval(gameInterval);
                }
                
                gameInterval = setInterval(gameLoop, speed);
            }
            
            function pauseGame() {
                isPaused = true;
                startPauseButton.textContent = 'Continuar';
                startPauseButton.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                startPauseButton.classList.add('bg-green-600', 'hover:bg-green-700');
                
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
            }
            
            function toggleStartPause() {
                if (isPaused || !gameInterval) {
                    startGame();
                } else {
                    pauseGame();
                }
            }
            
            function resetGame() {
                // Limpar intervalo
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
                
                // Resetar variáveis
                board = Array(config.rows).fill().map(() => Array(config.cols).fill(0));
                currentPiece = null;
                nextPiece = null;
                isPaused = false;
                isGameOver = false;
                score = 0;
                level = config.initialLevel;
                lines = 0;
                speed = 1000 - (level - 1) * 50;
                
                // Atualizar interface
                scoreElement.textContent = score;
                levelElement.textContent = level;
                linesElement.textContent = lines;
                startPauseButton.textContent = 'Iniciar';
                startPauseButton.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                startPauseButton.classList.add('bg-green-600', 'hover:bg-green-700');
                
                // Esconder game over
                gameOverElement.classList.add('hidden');
                
                // Recriar tabuleiro
                createBoard();
                
                // Voltar para a tab de jogo
                switchTab('info');
                
                drawBoard();
            }
            
            function gameOver() {
                isGameOver = true;
                
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
                
                finalScoreElement.textContent = score;
                gameOverElement.classList.remove('hidden');
                
                // Preencher nome do jogador com o último usado
                const lastPlayer = localStorage.getItem('lastPlayerName');
                if (lastPlayer) {
                    playerNameInput.value = lastPlayer;
                }
            }
            
            function handleKeyPress(event) {
                if (isGameOver) return;
                
                switch (event.key) {
                    case 'ArrowLeft':
                        movePiece('left');
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                        movePiece('right');
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                        movePiece('down');
                        event.preventDefault();
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        event.preventDefault();
                        break;
                    case ' ':
                        dropPiece();
                        event.preventDefault();
                        break;
                    case 'p':
                    case 'P':
                        toggleStartPause();
                        event.preventDefault();
                        break;
                }
            }
            
            // Gerenciamento de recordes
            function saveHighScore() {
                const playerName = playerNameInput.value.trim() || 'Jogador';
                
                // Salvar o nome para uso futuro
                localStorage.setItem('lastPlayerName', playerName);
                
                // Obter recordes existentes
                let highScores = JSON.parse(localStorage.getItem('tetrisHighScores')) || [];
                
                // Adicionar nova pontuação
                highScores.push({
                    name: playerName,
                    score: score,
                    level: level,
                    date: new Date().toISOString()
                });
                
                // Ordenar por pontuação (decrescente)
                highScores.sort((a, b) => b.score - a.score);
                
                // Manter apenas os 10 melhores
                highScores = highScores.slice(0, 10);
                
                // Salvar
                localStorage.setItem('tetrisHighScores', JSON.stringify(highScores));
                
                // Atualizar tabela
                loadHighScores();
                
                // Mudar para a tab de recordes
                switchTab('records');
                
                // Esconder o botão de salvar
                saveScoreButton.disabled = true;
                saveScoreButton.classList.add('opacity-50');
                saveScoreButton.textContent = 'Pontuação Salva';
            }
            
            function loadHighScores() {
                const highScores = JSON.parse(localStorage.getItem('tetrisHighScores')) || [];
                recordsBody.innerHTML = '';
                
                if (highScores.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = `<td colspan="4" class="text-center py-4">Nenhum recorde ainda</td>`;
                    recordsBody.appendChild(row);
                } else {
                    highScores.forEach((record, index) => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td>${index + 1}</td>
                            <td>${record.name}</td>
                            <td>${record.score}</td>
                            <td>${record.level}</td>
                        `;
                        recordsBody.appendChild(row);
                    });
                }
            }
            
            function clearHighScores() {
                if (confirm('Tem certeza que deseja limpar todos os recordes?')) {
                    localStorage.removeItem('tetrisHighScores');
                    loadHighScores();
                }
            }
            
            // Iniciar o jogo
            initGame();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'952d3ce954e7f204',t:'MTc1MDQ0MzE4My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
